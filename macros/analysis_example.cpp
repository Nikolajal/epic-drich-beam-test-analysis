/**
 * @file analysis_example.cpp
 * @brief Minimal example showing how to run an analysis on recodata.
 *
 * This file can be used as a template for your analysis.
 *
 * @section library_loader Loading the Libraries in ROOT Interactive Shell
 * Including this will automatically load the necessary libraries:
 * @code
 * #include "lib_loader.h"
 * @endcode
 * This file is automatically generated by CMake during installation and can be included from anywhere.
 *
 * @section data_structure Data Storage Pattern
 * The standard data storage layout is as follows:
 * `/data_storage_folder/run_tag/`
 *
 * In this folder, you can find:
 *   - **Raw ALCOR files**: divided by device.
 *     *Optional for analysis only*, provided you have `lightdata`, `recodata`, and `recotrackdata`.
 *     Required only if you need to build the analysis files.
 *   - **lightdata.root**: first-level data format. Consists of raw data divided into time frames, selected based on triggers.
 *   - **recodata.root**: second-level data format. Consists of `lightdata` with hits reconstructed, mapped, and calibrated.
 *   - **ALTAI/Gem (or other tracking system) folder**: storage for optional additional tracking information.
 *   - **recotrackdata.root**: optional recodata format integrated with tracking information if available.
 *
 * @section recodata_structure Reconstructed Data (recodata)
 * - Stored in a TTree with a single entry per frame.
 * - Hits are stored in vectors of the `alcor_recodata` class, linked to the tree through the `link_to_tree` method.
 * - Access hits using:
 *     - `get_recodata()` → returns a vector of `hit_struct`.
 *     - `get_hit_x(index)`, `get_hit_y(index)`, `get_hit_t(index)`, etc. → return the corresponding value for a given hit index.
 *
 * @section loading_recodata Loading recodata
 * A good practice is to check for the existence of recodata and load it as follows:
 * @code
 * // Input files
 * std::string input_filename_recodata = data_repository + "/" + run_name + "/recodata.root";
 *
 * // Load recodata, return if not available
 * TFile* input_file_recodata = new TFile(input_filename_recodata.c_str());
 * if (!input_file_recodata || input_file_recodata->IsZombie()) {
 *     std::cerr << "[WARNING] Could not find recodata, creating it..." << std::endl;
 *     return;
 * }
 *
 * // Link recodata tree locally
 * TTree* recodata_tree = (TTree*)input_file_recodata->Get("recodata");
 * alcor_recodata* recodata = new alcor_recodata();
 * recodata->link_to_tree(recodata_tree);
 * @endcode
 *  *
 * @section checking_triggers Checking the availability of triggers
 * 
 * A good practice is to check for the existence of triggers and use them as follows:
 * @code
 * auto default_hardware_trigger = recodata->get_trigger_by_index(0);
 * auto timing_trigger = recodata->get_timing_trigger();
 * @endcode
 * 
 * Please note that the spill structure is propagated by the use of a dedicated software trigger:
 * @code
 * //  Takes note of spill evolution
 * if (recodata->is_start_of_spill())
 * {
 *     //  You can internally keep track of spills
 *     i_spill++;
 *
 *     //  This event is not of physical interest, skip it
 *     continue;
 * }
 * @endcode
 */

#include "lib_loader.h"

void analysis_example(std::string data_repository, std::string run_name, int max_frames = 10000000)
{

  //  Input files
  std::string input_filename_recodata = data_repository + "/" + run_name + "/recodata.root";

  //  Load recodata, return if not available
  TFile *input_file_recodata = new TFile(input_filename_recodata.c_str());
  if (!input_file_recodata || input_file_recodata->IsZombie())
  {
    std::cerr << "[WARNING] Could not find recodata, making it" << std::endl;
    return;
  }

  //  Link recodata tree locally
  TTree *recodata_tree = (TTree *)input_file_recodata->Get("recodata");
  alcor_recodata *recodata = new alcor_recodata();
  recodata->link_to_tree(recodata_tree);

  //  Get number of frames, limited to maximum requested frames
  auto n_frames = recodata_tree->GetEntries();
  auto all_frames = min((int)n_frames, (int)max_frames);

  //  Map of hits
  TH2F *h_xy_hitmap = new TH2F("h_xy_hitmap", ";x (mm);y (mm)", 396, -99, 99, 396, -99, 99);
  TH1F *h_t_hit_htrg_distribution = new TH1F("h_t_hit_htrg_distribution", ";t_{hit} - t_{timing} (ns)", 600, -300, 300);
  TH1F *h_t_hit_ttrg_distribution = new TH1F("h_t_hit_ttrg_distribution", ";t_{hit} - t_{timing} (ns)", 600, -300, 300);
  TH1F *h_t_htrg_ttrg_distribution = new TH1F("h_t_htrg_ttrg_distribution", ";t_{hit} - t_{timing} (ns)", 600, -300, 300);

  //  Loop over frames
  auto i_spill = -1;
  for (int i_frame = 0; i_frame < all_frames; ++i_frame)
  {
    //  Load data for current frame
    recodata_tree->GetEntry(i_frame);

    //  Takes note of spill evolution
    if (recodata->is_start_of_spill())
    {
      //  You can internally keep track of spills
      i_spill++;

      //  This event is not of physical interest, skip it
      continue;
    }

    auto default_hardware_trigger = recodata->get_trigger_by_index(0);
    auto timing_trigger = recodata->get_timing_trigger();
    if (default_hardware_trigger && timing_trigger)
    {
      //  Loop on hits
      for (auto current_hit = 0; current_hit < recodata->get_recodata().size(); current_hit++)
      {
        //  Fill time distribution to check
        h_t_hit_htrg_distribution->Fill(recodata->get_hit_t(current_hit) - default_hardware_trigger->fine_time);
        h_t_hit_ttrg_distribution->Fill(recodata->get_hit_t(current_hit) - timing_trigger->fine_time);
        h_t_htrg_ttrg_distribution->Fill(default_hardware_trigger->fine_time - timing_trigger->fine_time);

        //  Cut in time to select coincidences
        if (fabs(recodata->get_hit_t(current_hit) - timing_trigger->fine_time) > 40)
          continue;

        //  Fill a hit wirth a random X and Y within the sensors acceptance (graphical purposes)
        h_xy_hitmap->Fill(recodata->get_hit_x_rnd(current_hit), recodata->get_hit_y_rnd(current_hit));
      }
    }
  }

  TCanvas *c1 = new TCanvas("hitmap", "", 600, 500);
  h_xy_hitmap->Draw("COLZ");
  TCanvas *c2 = new TCanvas("time distribution of hits w.r.t. trigger", "", 500, 500);
  h_t_hit_htrg_distribution->Draw();
  TCanvas *c3 = new TCanvas("time distribution of hits w.r.t. timing trigger", "", 500, 500);
  h_t_hit_ttrg_distribution->Draw();
  TCanvas *c4 = new TCanvas("time difference between hardware and timing triggers", "", 500, 500);
  h_t_htrg_ttrg_distribution->Draw();
}